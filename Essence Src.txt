getgenv().Depth = {
    Aimbot = {
        Binding = {
            Key = "Q",
            Mode = "Toggle"
        },
        Prediction = {
            Amount = 0.1,
            Auto_Prediction = {
                Use_Auto = true,
                Use_Ping = true,
                Use_Distance = true,
                Multiplier = {
                    Base = {
                        Prediction = 0.1
                    },
                    Ping = {
                        Divider = 1000
                    },
                    Distance = {
                        Divider = 10000
                    }
                }
            }
        },
        Camera = {
            Smoothing = 1
        },
        Target_Part = "UpperTorso",
        Jump_Offset = -1.5,
        Auto_Air = {
            Enabled = true,
            Delay = {
                Enabled = false,
                Delay_Amount = 1.5
            }
        },
        Notify = true
    },
    Resolver = {
        Enabled = true,
        Show_Status = true,
        Key = "N"
    },
    Macro = {
        Enabled = true,
        Keybind = "X"
    },
    Visuals = {
        FOV = {
            Visible = true,
            Radius = 120,
            Color = Color3.fromRGB(173, 216, 230),
            Transparency = 1
        },
        Highlight = {
            Enabled = true,
            Fill_Color = Color3.fromRGB(173, 216, 230),
            Outline_Color = Color3.fromRGB(0, 0, 0),
            Fill_Transparency = 0.5,
            Outline_Transparency = 0
        }
    }
}

for _, v in ipairs(getconnections(game:GetService("LogService").MessageOut)) do
    v:Disable()
end

local repl_storage = game:GetService("ReplicatedStorage")
if repl_storage:FindFirstChild("OpenAC Replicated Folder") then
    repl_storage["OpenAC Replicated Folder"]:Destroy()
end

if not getgenv().Depth.Loaded then
    

    local notificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/xaxas-notification/src.lua"))()
    local notifications = notificationLibrary.new({            
        NotificationLifetime = 3, 
        NotificationPosition = "TopLeft",
        TextFont = Enum.Font.Code,
        TextColor = Color3.fromRGB(255, 255, 255),
        TextSize = 15,
        TextStrokeTransparency = 0, 
        TextStrokeColor = Color3.fromRGB(0, 0, 0)
    })

    notifications:BuildNotificationUI()

    Script = {}
    Script.Functions = {}

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local CoreGui = game:GetService("CoreGui")
    local Players = game:GetService("Players")
    local Client = Players.LocalPlayer
    local Camera = workspace.CurrentCamera
    local Lighting = game:GetService("Lighting")
    local Locking = false
    local Resolving = false
    local Plr = nil
    setfpscap(9999)
    local PlayerData = {}

    local KnivesGui = Instance.new("ScreenGui")
    local LockButton = Instance.new("ImageButton")
    local MacroButton = Instance.new("ImageButton")

    KnivesGui.Name = "Depth (CoreGui)"
    KnivesGui.Parent = CoreGui
    KnivesGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    KnivesGui.ResetOnSpawn = false

    LockButton.Parent = KnivesGui
    LockButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    LockButton.BackgroundTransparency = 1.000
    LockButton.Position = UDim2.new(0.7, 0, 0.75, 0)  
    LockButton.Size = UDim2.new(0, 90, 0, 90)
    LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"

    MacroButton.Parent = KnivesGui
    MacroButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    MacroButton.BackgroundTransparency = 1.000
    MacroButton.Position = UDim2.new(0.85, 0, 0.75, 0)
    MacroButton.Size = UDim2.new(0, 90, 0, 90)
    MacroButton.Image = "rbxassetid://113276332333710"
    MacroButton.Visible = getgenv().Depth.Macro.Enabled

    local Highlight = Instance.new("Highlight")
    Highlight.FillColor = getgenv().Depth.Visuals.Highlight.Fill_Color
    Highlight.OutlineColor = getgenv().Depth.Visuals.Highlight.Outline_Color
    Highlight.FillTransparency = getgenv().Depth.Visuals.Highlight.Fill_Transparency
    Highlight.OutlineTransparency = getgenv().Depth.Visuals.Highlight.Outline_Transparency
    Highlight.Parent = game.CoreGui

    local FOVCircle = Drawing.new("Circle")
    FOVCircle.Transparency = 1
    FOVCircle.Thickness = 0.8
    FOVCircle.NumSides = 100
    FOVCircle.Color = getgenv().Depth.Visuals.FOV.Color
    FOVCircle.Filled = false

    local ResolverStatus = Drawing.new("Text")
    ResolverStatus.Visible = getgenv().Depth.Resolver.Show_Status
    ResolverStatus.Transparency = 1
    ResolverStatus.Color = Color3.fromRGB(255, 255, 255)
    ResolverStatus.Text = "Resolver: false"
    ResolverStatus.Size = 16
    ResolverStatus.Center = false
    ResolverStatus.Outline = true
    ResolverStatus.OutlineColor = Color3.fromRGB(0, 0, 0)
    ResolverStatus.Position = Vector2.new(20, Camera.ViewportSize.Y / 2)
    
    Script.Functions.CreateResolverTool = function()
        task.wait(1)
        local tool = Instance.new("Tool")
        tool.Name = "Resolver"
        tool.RequiresHandle = false
        tool.Parent = Client.Backpack

        tool.Activated:Connect(function()
            Resolving = not Resolving
            ResolverStatus.Text = "Resolver: " .. tostring(Resolving)
        end)
    end

    if UserInputService.TouchEnabled and getgenv().Depth.Resolver.Enabled then
        Script.Functions.CreateResolverTool()

        Client.CharacterAdded:Connect(function()
            Script.Functions.CreateResolverTool()
        end)
    end

    function UpdateFOV()
        if (not FOVCircle) then return end
        
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        FOVCircle.Visible = getgenv().Depth.Visuals.FOV.Visible
        FOVCircle.Radius = getgenv().Depth.Visuals.FOV.Radius * 2
        FOVCircle.Color = getgenv().Depth.Visuals.FOV.Color
        
        return FOVCircle
    end

    local lastAutoAirTime = 0

    Script.Functions.CalculateVelocity = function(player)
        if not player or not player.Character then return Vector3.new(0, 0, 0) end
        local primary_part = player.Character:FindFirstChild(getgenv().Depth.Aimbot.Target_Part)
        if not primary_part then return Vector3.new(0, 0, 0) end
        
        if not PlayerData[player] then
            PlayerData[player] = {
                PreviousPosition = primary_part.Position,
                Velocity = Vector3.new(0, 0, 0)
            }
        end
        
        local current_position = primary_part.Position
        local previous_position = PlayerData[player].PreviousPosition
        local displacement = current_position - previous_position
        local delta_time = RunService.Heartbeat:Wait()
        local velocity = displacement / delta_time
        
        PlayerData[player].Velocity = velocity
        PlayerData[player].PreviousPosition = current_position
        
        return velocity
    end

    Script.Functions.GetClosestPlrToCenter = function()
        if not Camera then return nil end
        local closestDist = getgenv().Depth.Visuals.FOV.Radius
        local closestPlr = nil
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        for _, v in pairs(Players:GetPlayers()) do
            if v ~= Client and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character.Humanoid.Health > 0 then
                local screenPos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    local distFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if distFromCenter < closestDist then
                        closestDist = distFromCenter
                        closestPlr = v
                    end
                end
            end
        end
        return closestPlr
    end

    Script.Functions.MakeDraggable = function(topbarobject, object)
        local Dragging = nil
        local DragInput = nil
        local DragStart = nil
        local StartPosition = nil
        
        local function Update(input)
            local Delta = input.Position - DragStart
            local pos = UDim2.new(StartPosition.X.Scale, StartPosition.X.Offset + Delta.X, StartPosition.Y.Scale, StartPosition.Y.Offset + Delta.Y)
            local Tween = TweenService:Create(object, TweenInfo.new(0.15), {Position = pos})
            Tween:Play()
        end
        
        if topbarobject then
            topbarobject.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    Dragging = true
                    DragStart = input.Position
                    StartPosition = object.Position
                    
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            Dragging = false
                        end
                    end)
                end
            end)
            
            topbarobject.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    DragInput = input
                end
            end)
            
            UserInputService.InputChanged:Connect(function(input)
                if input == DragInput and Dragging then
                    Update(input)
                end
            end)
        end
    end

    Script.Functions.MakeDraggable(LockButton, LockButton)
    Script.Functions.MakeDraggable(MacroButton, MacroButton)

    local function IsMouseButton(input)
        return string.match(input, "MouseButton%d+") ~= nil
    end

    local function GetKeyCode(input)
        if IsMouseButton(input) then
            return Enum.UserInputType[input]
        else
            return Enum.KeyCode[input]
        end
    end

    local Locking = false
    local Macroing = false
    local Plr = nil
    
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            local aimKey = GetKeyCode(getgenv().Depth.Aimbot.Binding.Key)
            local resolverKey = GetKeyCode(getgenv().Depth.Resolver.Key)
            
            if input.KeyCode == aimKey or input.UserInputType == aimKey then
                if getgenv().Depth.Aimbot.Binding.Mode == "Toggle" then
                    Locking = not Locking
                    if Locking then
                        LockButton.Image = "rbxasset://textures/ui/mouseLock_on@2x.png"
                        Plr = Script.Functions.GetClosestPlrToCenter()
                        if Plr and getgenv().Depth.Aimbot.Notify then
                            notifications:Notify(string.format("Locked on %s", Plr.DisplayName))
                        end
                    else
                        LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"
                        if Plr and getgenv().Depth.Aimbot.Notify then
                            notifications:Notify("Stopped Locking")
                        end
                        Plr = nil
                    end
                elseif getgenv().Depth.Aimbot.Binding.Mode == "Hold" then
                    Locking = true
                    LockButton.Image = "rbxasset://textures/ui/mouseLock_on@2x.png"
                    Plr = Script.Functions.GetClosestPlrToCenter()
                    if Plr and getgenv().Depth.Aimbot.Notify then
                        notifications:Notify(string.format("Locked on %s", Plr.DisplayName))
                    end
                end
            end
            
            if input.KeyCode == resolverKey or input.UserInputType == resolverKey then
                Resolving = not Resolving
                ResolverStatus.Text = "Resolver: " .. tostring(Resolving)
            end
            
            if input.KeyCode == Enum.KeyCode[getgenv().Depth.Macro.Keybind] then
                Macroing = not Macroing
                if Macroing then
                    MacroButton.ImageTransparency = 0
                else
                    MacroButton.ImageTransparency = 0.5
                end
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if not gameProcessed then
            local aimKey = GetKeyCode(getgenv().Depth.Aimbot.Binding.Key)
            if (input.KeyCode == aimKey or input.UserInputType == aimKey) and getgenv().Depth.Aimbot.Binding.Mode == "Hold" then
                Locking = false
                LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"
                if Plr and getgenv().Depth.Aimbot.Notify then
                    notifications:Notify("Stopped Locking")
                end
                Plr = nil
            end
        end
    end)

    if UserInputService.TouchEnabled then
        LockButton.MouseButton1Click:Connect(function()
            Locking = not Locking
            if Locking then
                LockButton.Image = "rbxasset://textures/ui/mouseLock_on@2x.png"
                Plr = Script.Functions.GetClosestPlrToCenter()
                if Plr and getgenv().Depth.Aimbot.Notify then
                    notifications:Notify(string.format("Locked on %s", Plr.DisplayName))
                end
            else
                LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"
                if Plr and getgenv().Depth.Aimbot.Notify then
                    notifications:Notify("Stopped Locking")
                end
                Plr = nil
            end
        end)

        MacroButton.MouseButton1Click:Connect(function()
            Macroing = not Macroing
            if Macroing then
                MacroButton.ImageTransparency = 0
            else
                MacroButton.ImageTransparency = 0.5
            end
        end)
    else
        LockButton.Visible = false
        MacroButton.Visible = false
    end

    Script.Functions.OnToolActivated = function()
        if not Locking or not Plr or not Plr.Character then return end
        local part = Plr.Character:FindFirstChild(getgenv().Depth.Aimbot.Target_Part)
        if not part then return end
        
        local Position = part.Position
        local velocity = Resolving and Script.Functions.CalculateVelocity(Plr) or part.AssemblyLinearVelocity
        
        local prediction
        if getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Auto then
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            local distance = (Client.Character.HumanoidRootPart.Position - part.Position).Magnitude
            
            if getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Ping and getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Distance then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (ping / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Ping.Divider) + 
                           (distance / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Distance.Divider)
            elseif getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Ping then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (ping / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Ping.Divider)
            elseif getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Distance then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (distance / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Distance.Divider)
            end
        else
            prediction = getgenv().Depth.Aimbot.Prediction.Amount
        end

        local PredictedPosition = Position + (velocity * prediction)
        
        local humanoid = Plr.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            PredictedPosition = PredictedPosition + Vector3.new(0, getgenv().Depth.Aimbot.Jump_Offset, 0)
        end
    end

    Script.Functions.SetupConnections = function()
        if not Client or not Client.Character then return end
        Client.Character.ChildAdded:Connect(function(child)
            if child and child:IsA("Tool") then
                child.Activated:Connect(Script.Functions.OnToolActivated)
            end
        end)
    end

    Script.Functions.SetupConnections()
    Client.CharacterAdded:Connect(Script.Functions.SetupConnections)

    RunService.Heartbeat:Connect(function()
        if not Client or not Client.Character then return end
        
        UpdateFOV()
        
        if getgenv().Depth.Macro.Enabled and Macroing and Client.Character:FindFirstChild("HumanoidRootPart") and Camera then
            local Look = Camera.CFrame.LookVector
            local Macro = Client.Character.HumanoidRootPart
            if Look and Macro then
                Macro.CFrame = CFrame.new(Macro.Position, Macro.Position + Vector3.new(Look.X, 0, Look.Z))
            end
        end

        if Locking and Plr and Plr.Character and getgenv().Depth.Aimbot.Auto_Air.Enabled then
            local humanoid = Plr.Character:FindFirstChild("Humanoid")
            local equipped = Client.Character:FindFirstChildOfClass("Tool")
            
            if humanoid and equipped and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                local currentTime = tick()
                if getgenv().Depth.Aimbot.Auto_Air.Delay.Enabled then
                    if currentTime - lastAutoAirTime >= getgenv().Depth.Aimbot.Auto_Air.Delay.Delay_Amount then
                        equipped:Activate()
                        lastAutoAirTime = currentTime
                    end
                else
                    equipped:Activate()
                end
            end
        end

        if getgenv().Depth.Visuals.Highlight.Enabled and Locking and Plr then
            Highlight.Adornee = Plr.Character
            Highlight.FillTransparency = getgenv().Depth.Visuals.Highlight.Fill_Transparency
            Highlight.OutlineTransparency = getgenv().Depth.Visuals.Highlight.Outline_Transparency
            Highlight.Enabled = true
        else
            Highlight.Adornee = nil
            Highlight.Enabled = false
        end
    end)

    RunService.PostSimulation:Connect(function()
        if not Locking or not Plr or not Plr.Character or not workspace.CurrentCamera then return end
        
        local targetPart = Plr.Character:FindFirstChild(getgenv().Depth.Aimbot.Target_Part)
        if not targetPart then return end
         
        local Position = targetPart.Position
        local humanoid = Plr.Character:FindFirstChild("Humanoid")
         
        if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            Position = Position + Vector3.new(0, getgenv().Depth.Aimbot.Jump_Offset, 0)
        end
         
        local velocity = Resolving and Script.Functions.CalculateVelocity(Plr) or targetPart.AssemblyLinearVelocity
        
        local prediction
        if getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Auto then
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            local distance = (Client.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
            
            if getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Ping and getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Distance then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (ping / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Ping.Divider) + 
                           (distance / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Distance.Divider)
            elseif getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Ping then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (ping / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Ping.Divider)
            elseif getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Distance then
                prediction = getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction + 
                           (distance / getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Distance.Divider)
            end
        else
            prediction = getgenv().Depth.Aimbot.Prediction.Amount
        end

        local targetPosition = Position + (velocity * prediction)
        
        workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(
            CFrame.lookAt(
                workspace.CurrentCamera.CFrame.Position,
                targetPosition
            ),
            getgenv().Depth.Aimbot.Camera.Smoothing
        )
    end)

    game.Players.PlayerRemoving:Connect(function(player)
        PlayerData[player] = nil
    end)

    getgenv().Depth.Loaded = true
end

local UserInputService = game:GetService("UserInputService")
local Player = game:GetService("Players").LocalPlayer

if UserInputService.TouchEnabled then
   local function CreateUITool()
       local Tool = Instance.new("Tool")
       Tool.Name = "UI"
       Tool.RequiresHandle = false
       Tool.Parent = Player.Backpack
       
       Tool.Activated:Connect(function()
           Library:Toggle()
       end)
   end
   
   CreateUITool()
   
   Player.CharacterAdded:Connect(function()
       task.wait()
       CreateUITool()
   end)
end

local repo = 'https://raw.githubusercontent.com/LionTheGreatRealFrFr/MobileLinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
   Title = 'Depth',
   Center = true, 
   AutoShow = true,
   TabPadding = 8,
   MenuFadeTime = 0.2
})

local Tabs = {
   Combat = Window:AddTab('Combat'),
   Visuals = Window:AddTab('Visuals'),
   ['UI Settings'] = Window:AddTab('UI Settings'),
}

local AimbotBox = Tabs.Combat:AddLeftGroupbox('Aimbot')

AimbotBox:AddLabel('Binding'):AddKeyPicker('AimbotKey', {
   Default = 'Q',
   Mode = 'Toggle',
   Text = 'Aimbot Keybind',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Binding.Key = Value
   end
})

AimbotBox:AddDropdown('AimbotMode', {
   Values = {'Toggle', 'Hold'},
   Default = 'Toggle',
   Text = 'Aimbot Mode',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Binding.Mode = Value
   end
})

AimbotBox:AddInput('PredictionAmount', {
   Default = "0.1",
   Numeric = false,
   Finished = false,
   Text = 'Prediction Amount',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Amount = tonumber(Value)
   end
})

AimbotBox:AddToggle('UseAuto', {
   Text = 'Use Auto Prediction',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Auto = Value
   end
})

AimbotBox:AddToggle('UsePing', {
   Text = 'Use Ping',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Ping = Value
   end
})

AimbotBox:AddToggle('UseDistance', {
   Text = 'Use Distance', 
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Use_Distance = Value
   end
})

AimbotBox:AddInput('BasePrediction', {
   Default = "0.1",
   Numeric = false,
   Finished = false,
   Text = 'Base Prediction',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Base.Prediction = tonumber(Value)
   end
})

AimbotBox:AddInput('PingDivider', {
   Default = "1000",
   Numeric = false,
   Finished = false,
   Text = 'Ping Divider',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Ping.Divider = tonumber(Value)
   end
})

AimbotBox:AddInput('DistanceDivider', {
   Default = "10000",
   Numeric = false,
   Finished = false,
   Text = 'Distance Divider',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Prediction.Auto_Prediction.Multiplier.Distance.Divider = tonumber(Value)
   end
})

AimbotBox:AddInput('JumpOffset', {
   Default = "-1.5",
   Numeric = false,
   Finished = false,
   Text = 'Jump Offset',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Jump_Offset = tonumber(Value)
   end
})

AimbotBox:AddDropdown('TargetPart', {
   Values = {'UpperTorso', 'HumanoidRootPart', 'Head'},
   Default = 'UpperTorso',
   Text = 'Target Part',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Target_Part = Value
   end
})

AimbotBox:AddToggle('AutoAir', {
   Text = 'Auto Air',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Auto_Air.Enabled = Value
   end
})

AimbotBox:AddToggle('AutoAirDelay', {
   Text = 'Auto Air Delay',
   Default = false,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Auto_Air.Delay.Enabled = Value
   end
})

AimbotBox:AddInput('AutoAirDelayAmount', {
   Default = "1.5",
   Numeric = false,
   Finished = false,
   Text = 'Delay Amount',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Auto_Air.Delay.Delay_Amount = tonumber(Value)
   end
})

AimbotBox:AddToggle('AimbotNotify', {
   Text = 'Notify',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Aimbot.Notify = Value
   end
})

local CameraBox = Tabs.Combat:AddRightGroupbox('Camera')

CameraBox:AddInput('CameraSmoothness', {
   Default = "1",
   Numeric = false,
   Finished = false,
   Text = 'Camera Smoothing',
   Callback = function(Value)
       getgenv().Depth.Aimbot.Camera.Smoothing = tonumber(Value)
   end
})

local ResolverBox = Tabs.Combat:AddRightGroupbox('Resolver')

ResolverBox:AddToggle('ResolverEnabled', {
   Text = 'Enable Resolver',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Resolver.Enabled = Value
   end
})

ResolverBox:AddToggle('ShowStatus', {
   Text = 'Show Status',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Resolver.Show_Status = Value
   end
})

ResolverBox:AddLabel('Resolver Key'):AddKeyPicker('ResolverKey', {
   Default = 'N',
   Text = 'Resolver Keybind',
   Callback = function(Value)
       getgenv().Depth.Resolver.Key = Value
   end
})

local MacroBox = Tabs.Combat:AddRightGroupbox('Macro')

MacroBox:AddToggle('MacroEnabled', {
   Text = 'Enable Macro',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Macro.Enabled = Value
   end
})

MacroBox:AddLabel('Macro Key'):AddKeyPicker('MacroKey', {
   Default = 'X',
   Text = 'Macro Keybind',
   Callback = function(Value)
       getgenv().Depth.Macro.Keybind = Value
   end
})

local FOVBox = Tabs.Visuals:AddLeftGroupbox('FOV Settings')

FOVBox:AddToggle('FOVVisible', {
   Text = 'Show FOV Circle',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Visuals.FOV.Visible = Value
   end
})

FOVBox:AddInput('FOVRadius', {
   Default = "120",
   Numeric = false,
   Finished = false,
   Text = 'FOV Radius',
   Callback = function(Value)
       getgenv().Depth.Visuals.FOV.Radius = tonumber(Value)
   end
})

FOVBox:AddInput('FOVTransparency', {
   Default = "1",
   Numeric = false,
   Finished = false,
   Text = 'FOV Transparency',
   Callback = function(Value)
       getgenv().Depth.Visuals.FOV.Transparency = tonumber(Value)
   end
})

FOVBox:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
   Default = Color3.fromRGB(173, 216, 230),
   Title = 'FOV Circle Color',
   Callback = function(Value)
       getgenv().Depth.Visuals.FOV.Color = Value
   end
})

local HighlightBox = Tabs.Visuals:AddRightGroupbox('Highlight Settings')

HighlightBox:AddToggle('HighlightEnabled', {
   Text = 'Enable Highlight',
   Default = true,
   Callback = function(Value)
       getgenv().Depth.Visuals.Highlight.Enabled = Value
   end
})

HighlightBox:AddLabel('Highlight Fill'):AddColorPicker('HighlightFill', {
   Default = Color3.fromRGB(173, 216, 230),
   Title = 'Highlight Fill Color',
   Transparency = 0.5,
   Callback = function(Value)
       getgenv().Depth.Visuals.Highlight.Fill_Color = Value
   end
})

HighlightBox:AddInput('HighlightFillTransparency', {
   Default = "0.5",
   Numeric = false,
   Finished = false,
   Text = 'Fill Transparency',
   Callback = function(Value)
       getgenv().Depth.Visuals.Highlight.Fill_Transparency = tonumber(Value)
   end
})

HighlightBox:AddLabel('Highlight Outline'):AddColorPicker('HighlightOutline', {
   Default = Color3.fromRGB(0, 0, 0),
   Title = 'Highlight Outline Color',
   Callback = function(Value)
       getgenv().Depth.Visuals.Highlight.Outline_Color = Value
   end
})

HighlightBox:AddInput('HighlightOutlineTransparency', {
   Default = "0",
   Numeric = false,
   Finished = false,
   Text = 'Outline Transparency',
   Callback = function(Value)
       getgenv().Depth.Visuals.Highlight.Outline_Transparency = tonumber(Value)
   end
})

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('Depth')
SaveManager:SetFolder('Depth/Configs')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
   FrameCounter += 1
   if (tick() - FrameTimer) >= 1 then
       FPS = FrameCounter
       FrameTimer = tick()
       FrameCounter = 0
   end
   Library:SetWatermark(('Depth | %s fps | %s ms'):format(
       math.floor(FPS),
       math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
   ))
end)

Library.KeybindFrame.Visible = true

Library:OnUnload(function()
   WatermarkConnection:Disconnect()
   Library.Unloaded = true
end)